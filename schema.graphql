directive @auth(scopes: [String!]) on FIELD_DEFINITION

input AddMylistToMylistGroupInput {
  groupId: ID!
  mylistId: ID!
}

type AddMylistToMylistGroupPayload {
  inclusion: MylistGroupMylistInclusion!
}

enum AddSemitagToVideoFailedMessage {
  """すでに同名の仮タグが付いている"""
  ALREADY_ATTACHED

  """すでにこの仮タグはチェックした"""
  ALREADY_CHECKED
  FORBIDDEN
  INVALID_VIDEO_ID
  UNKNOWN
  VIDEO_NOT_FOUND
}

type AddSemitagToVideoFailedPayload {
  message: AddSemitagToVideoFailedMessage!
}

input AddSemitagToVideoInput {
  name: String!
  videoId: ID!
}

union AddSemitagToVideoPayload = AddSemitagToVideoFailedPayload | AddSemitagToVideoSucceededPayload

type AddSemitagToVideoSucceededPayload {
  semitag: Semitag!
}

enum AddTagToVideoFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  INVALID_VIDEO_ID

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_ALREADY_TAGGED
}

type AddTagToVideoFailedPayload {
  message: AddTagToVideoFailedMessage!
}

input AddTagToVideoInput {
  tagId: ID!
  videoId: ID!
}

union AddTagToVideoPayload = AddTagToVideoFailedPayload | AddTagToVideoSucceededPayload

type AddTagToVideoSucceededPayload {
  tag: Tag!
  video: Video!
}

type AddVideoToMylistAlreadyRegisteredError {
  registration: MylistRegistration!
}

input AddVideoToMylistInput {
  mylistId: ID!
  note: String
  videoId: ID!
}

enum AddVideoToMylistOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type AddVideoToMylistOtherErrorsFallback {
  message: AddVideoToMylistOtherErrorMessage!
}

union AddVideoToMylistReturnUnion = AddVideoToMylistAlreadyRegisteredError | AddVideoToMylistOtherErrorsFallback | AddVideoToMylistSucceededPayload | MutationInvalidMylistIdError | MutationInvalidVideoIdError | MutationMylistNotFoundError | MutationVideoNotFoundError | MutationWrongMylistHolderError

type AddVideoToMylistSucceededPayload {
  registration: MylistRegistration!
}

input ChangeMylistShareRangeInput {
  mylistId: ID!
  range: MylistShareRange!
}

enum ChangeMylistShareRangeOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type ChangeMylistShareRangeOtherErrorsFallback {
  message: ChangeMylistShareRangeOtherErrorMessage!
}

type ChangeMylistShareRangeSucceededPayload {
  mylist: Mylist!
}

union ChangeMylistShareReturnUnion = ChangeMylistShareRangeOtherErrorsFallback | ChangeMylistShareRangeSucceededPayload | MutationInvalidMylistIdError | MutationMylistNotFoundError | MutationWrongMylistHolderError

input CreateMylistGroupInput {
  title: String!
}

type CreateMylistGroupPayload {
  group: MylistGroup!
}

input CreateMylistInput {
  range: MylistShareRange!

  """URLなどで使う簡単な識別子"""
  slug: String!
  title: String!
}

enum CreateMylistOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type CreateMylistOtherErrorsFallback {
  message: CreateMylistOtherErrorMessage!
}

union CreateMylistReturnUnion = CreateMylistOtherErrorsFallback | CreateMylistSucceededPayload

type CreateMylistSucceededPayload {
  mylist: Mylist!
}

input CreateTemporaryUserInput {
  alias: String!
  displayName: String!
}

union CreateTemporaryUserReturnUnion = CreateTemporaryUserSucceededPayload

type CreateTemporaryUserSucceededPayload {
  id: ID!
}

scalar DateTime

interface Event implements Node {
  createdAt: DateTime!
  id: ID!

  """createdAtでのソートが不可能なので，別のEvent同士を混合してソートする際に必要．"""
  series: String!
  user: User!
}

"""その他のエラー"""
type ExplicitizeTagAlreadyExplicitError {
  already: TagParent!
}

enum ExplicitizeTagOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type ExplicitizeTagOtherErrorsFallback {
  message: ExplicitizeTagOtherErrorMessage!
}

input ExplicitizeTagParentInput {
  """親子関係のID"""
  relationId: ID!
}

union ExplicitizeTagParentReturnUnion = ExplicitizeTagAlreadyExplicitError | ExplicitizeTagOtherErrorsFallback | ExplicitizeTagSucceededPayload | MutationInvalidTagParentIdError | MutationTagParentNotFoundError

type ExplicitizeTagSucceededPayload {
  relation: TagParent!
}

input FetchNicovideoInput {
  """ニコニコ動画の動画ID（sm2057168など）"""
  sourceId: String!
}

type FetchNicovideoPayload {
  source: NicovideoOriginalSource
}

type FetchYoutubePayload {
  source: YoutubeOriginalSource
}

input FindMylistInput {
  pair: FindMylistInputHolderNameMylistSlugPair!
}

input FindMylistInputHolderNameMylistSlugPair {
  holderName: String!
  mylistSlug: String!
}

input FindNicovideoRegistrationRequestInput {
  id: ID
  sourceId: String
}

input FindNicovideoRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

input FindNicovideoVideoSourceInput {
  sourceId: String
}

input FindSemitagsOrderBy {
  createdAt: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input FindTagInput {
  id: ID
  serial: Int
}

input FindTagsInput {
  limit: Int! = 10

  """正確に一致"""
  name: String
  order: FindTagsInputOrder! = {updatedAt: DESC}
  parents: [ID!]
  skip: Int! = 0
}

input FindTagsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FindUserInput {
  name: String
}

input FindVideoInput {
  id: ID
  serial: Int
}

input FindVideosOrderBy {
  createdAt: SortOrder
}

"""指定したTagParentRelationがそもそも非明示的だった場合のエラー"""
type ImplicitizeTagAlreadyImplicitError {
  relation: TagParent!
}

enum ImplicitizeTagOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type ImplicitizeTagOtherErrorsFallback {
  message: ImplicitizeTagOtherErrorMessage!
}

input ImplicitizeTagParentInput {
  """親子関係のID"""
  relationId: ID!
}

union ImplicitizeTagParentReturnUnion = ImplicitizeTagAlreadyImplicitError | ImplicitizeTagOtherErrorsFallback | ImplicitizeTagSucceededPayload | MutationInvalidTagParentIdError | MutationTagParentNotFoundError

type ImplicitizeTagSucceededPayload {
  relation: TagParent!
}

type LikeVideoAlreadyLikedError {
  registration: MylistRegistration!
}

input LikeVideoInput {
  videoId: ID!
}

union LikeVideoReturnUnion = LikeVideoAlreadyLikedError | LikeVideoSucceededPayload | MutationInvalidVideoIdError | MutationVideoNotFoundError

type LikeVideoSucceededPayload {
  registration: MylistRegistration!
}

type Mutation {
  addMylistToMylistGroup(input: AddMylistToMylistGroupInput!): AddMylistToMylistGroupPayload!
  addSemitagToVideo(input: AddSemitagToVideoInput!): AddSemitagToVideoPayload!
  addTagToVideo(input: AddTagToVideoInput!): AddTagToVideoPayload!
  addVideoToMylist(input: AddVideoToMylistInput!): AddVideoToMylistReturnUnion!
  changeMylistShareRange(input: ChangeMylistShareRangeInput!): ChangeMylistShareReturnUnion!
  createMylist(input: CreateMylistInput!): CreateMylistReturnUnion!
  createMylistGroup(input: CreateMylistGroupInput!): CreateMylistGroupPayload!
  createTemporaryUser(input: CreateTemporaryUserInput!): CreateTemporaryUserReturnUnion!

  """非明示的なタグの親子関係を明示的に昇格する"""
  explicitizeTagParent(input: ExplicitizeTagParentInput!): ExplicitizeTagParentReturnUnion!

  """明示的なタグの親子関係を非明示的に降格する"""
  implicitizeTagParent(input: ImplicitizeTagParentInput!): ImplicitizeTagParentReturnUnion!
  likeVideo(input: LikeVideoInput!): LikeVideoReturnUnion!
  registerCategoryTag(input: RegisterCategoryTagInput!): RegisterCategoryTagResultUnion!
  registerCategoryTagTyping(input: RegisterCategoryTagTypingInput!): RegisterCategoryTagTypingResultUnion!
  registerTag(input: RegisterTagInput!): RegisterTagReturnUnion!
  registerTagParentRelation(input: RegisterTagParentRelationInput!): RegisterTagParentRelationResultUnion!
  registerVideoFromNicovideo(input: RegisterVideoFromNicovideoInput!): RegisterVideoFromNicovideoPayload!
  registerVideoFromYoutube(input: RegisterVideoFromYoutubeInput!): RegisterVideoFromYoutubePayload!
  rejectNicovideoRegistrationRequest(input: RejectNicovideoRegistrationRequestInput!): RejectNicovideoRegistrationRequestReturnUnion!
  rejectSemitag(semitagId: ID!): RejectSemitagReturnUnion!
  removeTagFromVideo(input: RemoveTagFromVideoInput!): RemoveTagFromVideoPayload!
  removeVideoFromMylist(input: RemoveVideoFromMylistInput!): RemoveVideoFromMylistPayload!
  requestNicovideoRegistration(input: RequestNicovideoRegistrationInput!): RequestNicovideoRegistrationReturnUnion!
  resovleSemitag(semitagId: ID!, tagId: ID!): ResolveSemitagReturnUnion!
  undoLikeVideo(input: UndoLikeVideoInput!): UndoLikeVideoReturnUnion!
  verifyTemporaryUser: VerifyTemporaryUserReturnUnion!
}

"""MylistのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidMylistIdError {
  """無効なID"""
  mylistId: String!
}

"""NicovideoRegistrationRequestのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidNicovideoRegistrationRequestIdError {
  """無効なID"""
  requestId: String!
}

"""SemitagのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidSemitagIdError {
  semitagId: String!
}

"""TagのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidTagIdError {
  """無効なID"""
  tagId: String!
}

"""TagParentのIDとして不正なIDを入力した場合のMutation用エラー"""
type MutationInvalidTagParentIdError {
  relationId: String!
}

"""VideoのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidVideoIdError {
  """無効なID"""
  videoId: String!
}

"""Mylistが見つからない場合のエラー"""
type MutationMylistNotFoundError {
  mylistId: String!
}

"""既にチェック済みのNicovideoRegistrationRequestをチェックしようとした場合のエラー"""
type MutationNicovideoRegistrationRequestAlreadyCheckedError {
  requestId: String!
}

"""NicovideoRegistrationRequestが見つからない場合のエラー"""
type MutationNicovideoRegistrationRequestNotFoundError {
  requestId: String!
}

"""チェック済みのSemitagに操作を加えようとした場合のエラー"""
type MutationSemitagAlreadyCheckedError {
  semitag: Semitag!
}

"""Semitagが見つからない場合のエラー"""
type MutationSemitagNotFoundError {
  semitagId: String!
}

"""Tagが見つからない場合のエラー"""
type MutationTagNotFoundError {
  tagId: String!
}

"""TagParentが見つからない場合のMutation用エラー"""
type MutationTagParentNotFoundError {
  relationId: String!
}

"""Videoが見つからない場合のエラー"""
type MutationVideoNotFoundError {
  videoId: String!
}

"""Mylistの所有者が違う場合のエラー"""
type MutationWrongMylistHolderError {
  mylistId: String!
}

type Mylist implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  includeTags(input: MylistIncludeTagsInput!): MylistIncludeTagsPayload!

  """マイリストの中にビデオが追加されているか．"""
  isIncludesVideo(id: ID!): Boolean!
  isLikeList: Boolean!
  range: MylistShareRange!
  recommendedVideos(input: MylistRecommendedVideosInput!): MylistRecommendedVideosPayload!
  registrations(after: String, before: String, first: Int, last: Int, orderBy: MylistRegistrationsOrderBy! = {createdAt: DESC}): MylistRegistrationConnection!
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type MylistConnection {
  edges: [MylistEdge!]!
  nodes: [Mylist!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MylistEdge {
  cursor: String!
  node: Mylist!
}

type MylistGroup implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  mylists(input: MylistGroupMylistsInput!): MylistGroupMylistInclusionConnection!
  title: String!
  updatedAt: DateTime!
  videos(input: MylistGroupVideosInput!): [MylistGroupVideoAggregation!]!
}

type MylistGroupMylistInclusion implements Node {
  createdAt: DateTime!
  group: MylistGroup!
  id: ID!
  mylist: Mylist!
  updatedAt: DateTime!
}

type MylistGroupMylistInclusionConnection {
  nodes: [MylistGroupMylistInclusion!]!
}

input MylistGroupMylistsInput {
  limit: Int! = 10
  order: MylistGroupMylistsInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input MylistGroupMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type MylistGroupVideoAggregation {
  """動画を含んでいるマイリストの数"""
  count: Int!

  """動画を含んでいるマイリスト"""
  mylists(input: MylistGroupVideoAggregationMylistsInput!): [Mylist!]!
  video: Video!
}

input MylistGroupVideoAggregationMylistsInput {
  limit: Int! = 10
  order: MylistGroupVideoAggregationMylistsInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input MylistGroupVideoAggregationMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input MylistGroupVideosInput {
  limit: Int! = 10
  order: MylistGroupVideosInputOrder! = {count: DESC}
  skip: Int! = 0
}

input MylistGroupVideosInputOrder {
  count: SortOrder!
}

input MylistIncludeTagsInput {
  limit: Int! = 10
  order: MylistIncludeTagsInputOrder! = {count: DESC}
  skip: Int! = 0
}

input MylistIncludeTagsInputOrder {
  count: SortOrder!
}

type MylistIncludeTagsPayload {
  items: [MylistTagInclusion!]!
}

input MylistRecommendedVideosInput {
  limit: Int! = 10
}

type MylistRecommendedVideosPayload {
  items: [MylistVideoRecommendation!]!
}

type MylistRegistration implements Node {
  createdAt: DateTime!
  id: ID!
  mylist: Mylist!
  note: String
  updatedAt: DateTime!
  video: Video!
}

type MylistRegistrationConnection {
  edges: [MylistRegistrationEdge!]!
  nodes: [MylistRegistration!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MylistRegistrationEdge {
  cursor: String!
  node: MylistRegistration!
}

input MylistRegistrationsOrderBy {
  createdAt: SortOrder
}

enum MylistShareRange {
  KNOW_LINK
  PRIVATE
  PUBLIC
}

type MylistTagInclusion {
  count: Int!
  mylist: Mylist!
  tag: Tag!
}

type MylistVideoRecommendation {
  origin: Mylist!
  score: Float!
  to: Video!
}

type NicovideoOriginalSource {
  countComments: Int!
  countLikes: Int!
  countMylists: Int!
  countViews: Int!

  """動画の長さ"""
  duration: Int!

  """タグのうち、「音MAD」など範囲が広すぎるので除外するもの"""
  excludeTags: [String!]!
  registeredAt: DateTime!
  sourceId: String!
  tags: [NicovideoOriginalSourceTag!]!
  thumbnailUrl: String!
  title: String!
}

type NicovideoOriginalSourceTag {
  name: String!
  searchTags(input: NicovideoOriginalSourceTagSearchTagsInput!): NicovideoOriginalSourceTagSearchTagsPayload!
}

input NicovideoOriginalSourceTagSearchTagsInput {
  limit: Int! = 3
  skip: Int! = 0
}

type NicovideoOriginalSourceTagSearchTagsPayload {
  items: [TagSearchItemByName!]!
}

type NicovideoRegistrationRequest {
  checked: Boolean!
  checking: NicovideoRegistrationRequestChecking
  embedUrl: String!
  id: ID!
  originalUrl: String!
  requestedBy: User!
  semitaggings: [NicovideoRegistrationRequestSemitagging!]!
  sourceId: String!
  taggings: [NicovideoRegistrationRequestTagging!]!
  thumbnailUrl: String!
  title: String!
}

type NicovideoRegistrationRequestAccepting {
  acceptedBy: User!
  note: String
  request: NicovideoRegistrationRequest!
  video: Video!
}

type NicovideoRegistrationRequestAcceptingNotification implements Node & Notification {
  accepting: NicovideoRegistrationRequestAccepting!
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  watched: Boolean!
}

union NicovideoRegistrationRequestChecking = NicovideoRegistrationRequestAccepting | NicovideoRegistrationRequestRejecting

type NicovideoRegistrationRequestConnection {
  edges: [NicovideoRegistrationRequestEdge!]!
  nodes: [NicovideoRegistrationRequest!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NicovideoRegistrationRequestEdge {
  cursor: String!
  node: NicovideoRegistrationRequest!
}

type NicovideoRegistrationRequestRejecting {
  note: String
  rejectedBy: User!
  request: NicovideoRegistrationRequest!
}

type NicovideoRegistrationRequestRejectingNotification implements Node & Notification {
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  rejecting: NicovideoRegistrationRequestRejecting!
  watched: Boolean!
}

type NicovideoRegistrationRequestSemitagging {
  id: ID!
  name: String!
  note: String
}

type NicovideoRegistrationRequestTagging {
  id: ID!
  note: String
  tag: Tag!
}

type NicovideoVideoSource implements Node & VideoSource {
  embedUrl: String!
  events(input: NicovideoVideoSourceEventsInput!): NicovideoVideoSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type NicovideoVideoSourceCreateEvent implements Event & NicovideoVideoSourceEvent & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: NicovideoVideoSource!
  user: User!
}

interface NicovideoVideoSourceEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: NicovideoVideoSource!
  user: User!
}

type NicovideoVideoSourceEventConnection {
  nodes: [NicovideoVideoSourceEvent!]!
}

input NicovideoVideoSourceEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

interface Node {
  id: ID!
}

interface Notification implements Node {
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  watched: Boolean!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  nodes: [Notification!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NotificationEdge {
  cursor: String!
  node: Notification!
}

input NotificationsFilter {
  watched: Boolean
}

input NotificationsOrderBy {
  createdAt: SortOrder
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  """ニコニコ動画から動画情報を取得する"""
  fetchNicovideo(input: FetchNicovideoInput!): FetchNicovideoPayload!

  """Youtubeから動画情報を取得する"""
  fetchYoutube(
    """Youtubeの動画ID（Q16KpquGsIcなど）"""
    sourceId: String!
  ): FetchYoutubePayload!
  findMylist(input: FindMylistInput!): Mylist
  findNicovideoRegistrationRequest(input: FindNicovideoRegistrationRequestInput): NicovideoRegistrationRequest
  findNicovideoRegistrationRequests(after: String, before: String, checked: Boolean, first: Int, last: Int, orderBy: FindNicovideoRegistrationRequestsOrderBy! = {createdAt: DESC}): NicovideoRegistrationRequestConnection!
  findNicovideoVideoSource(input: FindNicovideoVideoSourceInput!): NicovideoVideoSource
  findSemitags(after: String, before: String, checked: Boolean, first: Int, last: Int, orderBy: FindSemitagsOrderBy! = {name: ASC}): SemitagConnection!
  findTag(input: FindTagInput!): Tag
  findTags(input: FindTagsInput!): TagConnection!
  findUser(input: FindUserInput!): User
  findVideo(input: FindVideoInput!): Video
  findVideos(after: String, before: String, first: Int, last: Int, orderBy: FindVideosOrderBy! = {createdAt: DESC}): VideoConnection!
  findYoutubeVideoSource(sourceId: String): YoutubeVideoSource
  getMylist(id: ID!): Mylist!
  getMylistGroup(id: ID!): MylistGroup!
  getNicovideoRegistrationRequest(id: ID!): NicovideoRegistrationRequest!
  getNicovideoVideoSource(id: ID!): NicovideoVideoSource!
  getNotification(id: ID!): Notification!
  getSemitag(id: ID!): Semitag!
  getTag(id: ID!): Tag!
  getUser(id: ID!): User!
  getVideo(id: ID!): Video!
  getYoutubeVideoSource(id: ID!): YoutubeVideoSource!
  notifications(after: String, before: String, filter: NotificationsFilter! = {}, first: Int, last: Int, orderBy: NotificationsOrderBy! = {createdAt: DESC}): NotificationConnection!
  searchTags(input: SearchTagInput!): SearchTagsPayload!
  searchVideos(input: SearchVideoInput!): SearchVideosPayload!
  whoami: User!
}

input RegisterCategoryTagInput {
  primaryName: String!
}

enum RegisterCategoryTagOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type RegisterCategoryTagOtherErrorsFallback {
  message: RegisterCategoryTagOtherErrorMessage!
}

union RegisterCategoryTagResultUnion = RegisterCategoryTagOtherErrorsFallback | RegisterCategoryTagSucceededPayload

type RegisterCategoryTagSucceededPayload {
  tag: Tag!
}

"""指定されたタイプのカテゴリータグが既に存在する場合のエラー"""
type RegisterCategoryTagTypingAlreadyTypeExistsError {
  already: Tag!
}

"""指定されたカテゴリータグに既にタイプがある場合のエラー"""
type RegisterCategoryTagTypingAlreadyTypedError {
  tag: Tag!
}

input RegisterCategoryTagTypingInput {
  tagId: ID!
  type: TagType!
}

"""指定されたタグはカテゴリータグでは無い場合のエラー"""
type RegisterCategoryTagTypingNotCategoryTagError {
  tag: Tag!
}

enum RegisterCategoryTagTypingOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type RegisterCategoryTagTypingOtherErrorsFallback {
  message: RegisterCategoryTagTypingOtherErrorMessage!
}

union RegisterCategoryTagTypingResultUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RegisterCategoryTagTypingAlreadyTypeExistsError | RegisterCategoryTagTypingAlreadyTypedError | RegisterCategoryTagTypingNotCategoryTagError | RegisterCategoryTagTypingOtherErrorsFallback | RegisterCategoryTagTypingSucceededPayload | RegisterCategoryTagTypingUnsupportedTagType

type RegisterCategoryTagTypingSucceededPayload {
  tag: Tag!
}

type RegisterCategoryTagTypingUnsupportedTagType {
  type: TagType!
}

"""非明示的な親タグのIDが重複している"""
type RegisterTagImplicitParentIdsDuplicatedError {
  tagId: String!
}

input RegisterTagInput {
  explicitParent: ID
  extraNames: [String!]! = []
  implicitParents: [ID!]! = []
  primaryName: String!
  resolveSemitags: [ID!]! = []
}

type RegisterTagOtherErrorsFallback {
  message: RegisterTagOtherErrorsFallbackMessage!
}

enum RegisterTagOtherErrorsFallbackMessage {
  UNKNOWN
}

"""子タグに既に明示的な親子関係が存在する場合のエラー"""
type RegisterTagParentRelationChildTagAlreadyHadExplicitParentError {
  relation: TagParent!
}

input RegisterTagParentRelationInput {
  childId: ID!
  explicit: Boolean!
  parentId: ID!
}

enum RegisterTagParentRelationOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type RegisterTagParentRelationOtherErrorsFallback {
  message: RegisterTagParentRelationOtherErrorMessage!
}

"""既に登録されていた場合のエラー"""
type RegisterTagParentRelationRelationAlreadyRegisteredError {
  relation: TagParent!
}

union RegisterTagParentRelationResultUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RegisterTagParentRelationChildTagAlreadyHadExplicitParentError | RegisterTagParentRelationOtherErrorsFallback | RegisterTagParentRelationRelationAlreadyRegisteredError | RegisterTagParentRelationSucceededPayload

type RegisterTagParentRelationSucceededPayload {
  relation: TagParent!
}

"""解決されるSemitagが既にチェック済みである"""
type RegisterTagResolveSemitagAlreadyCheckedError {
  semitagId: String!
}

"""解決されるSemitagのIDが重複している"""
type RegisterTagResolveSemitagIdsDuplicatedError {
  semitagId: String!
}

union RegisterTagReturnUnion = MutationInvalidSemitagIdError | MutationInvalidTagIdError | MutationSemitagNotFoundError | MutationTagNotFoundError | RegisterTagImplicitParentIdsDuplicatedError | RegisterTagOtherErrorsFallback | RegisterTagResolveSemitagAlreadyCheckedError | RegisterTagResolveSemitagIdsDuplicatedError | RegisterTagSucceededPayload | RegisterTagTagIdCollidedBetweenExplicitAndImplicitError

type RegisterTagSucceededPayload {
  tag: Tag!
}

"""明示的な親タグのIDと非明示的な親タグのIDが重複している"""
type RegisterTagTagIdCollidedBetweenExplicitAndImplicitError {
  tagId: String!
}

enum RegisterVideoFromNicovideoFailedMessage {
  INTERNAL_SERVER_ERROR
}

input RegisterVideoFromNicovideoInput {
  extraTitles: [String!]! = []
  primaryThumbnailUrl: String!
  primaryTitle: String!
  requestId: ID
  semitagNames: [String!]! = []
  sourceIds: [String!]!
  tagIds: [ID!]!
}

"""ニコニコ動画のソースIDとして不正な場合のエラー"""
type RegisterVideoFromNicovideoInvalidNicovideoSourceIdError {
  sourceID: String!
}

"""その他のエラー"""
type RegisterVideoFromNicovideoOtherErrorsFallback {
  message: RegisterVideoFromNicovideoFailedMessage!
}

union RegisterVideoFromNicovideoPayload = MutationInvalidNicovideoRegistrationRequestIdError | MutationInvalidTagIdError | MutationNicovideoRegistrationRequestAlreadyCheckedError | MutationNicovideoRegistrationRequestNotFoundError | MutationTagNotFoundError | RegisterVideoFromNicovideoInvalidNicovideoSourceIdError | RegisterVideoFromNicovideoOtherErrorsFallback | RegisterVideoFromNicovideoSemitagNamesDuplicatedError | RegisterVideoFromNicovideoSemitagTooLongError | RegisterVideoFromNicovideoSucceededPayload | RegisterVideoFromNicovideoTagIdsDuplicatedError

"""仮タグの名前が重複している"""
type RegisterVideoFromNicovideoSemitagNamesDuplicatedError {
  name: String!
}

"""仮タグの名前が長過ぎる"""
type RegisterVideoFromNicovideoSemitagTooLongError {
  name: String!
}

"""成功した場合"""
type RegisterVideoFromNicovideoSucceededPayload {
  video: Video!
}

"""タグのIDが重複している"""
type RegisterVideoFromNicovideoTagIdsDuplicatedError {
  tagId: String!
}

enum RegisterVideoFromYoutubeFailedMessage {
  INTERNAL_SERVER_ERROR
}

input RegisterVideoFromYoutubeInput {
  extraTitles: [String!]! = []
  primaryThumbnailUrl: String!
  primaryTitle: String!
  semitagNames: [String!]! = []
  sourceIds: [String!]!
  tagIds: [ID!]!
}

"""Youtubeの動画IDとして不正な場合のエラー"""
type RegisterVideoFromYoutubeInvalidYoutubeSourceIdError {
  sourceID: String!
}

"""その他のエラー"""
type RegisterVideoFromYoutubeOtherErrorsFallback {
  message: RegisterVideoFromYoutubeFailedMessage!
}

union RegisterVideoFromYoutubePayload = MutationInvalidTagIdError | MutationTagNotFoundError | RegisterVideoFromYoutubeInvalidYoutubeSourceIdError | RegisterVideoFromYoutubeOtherErrorsFallback | RegisterVideoFromYoutubeSemitagNamesDuplicatedError | RegisterVideoFromYoutubeSucceededPayload | RegisterVideoFromYoutubeTagIdsDuplicatedError

"""仮タグの名前が重複している"""
type RegisterVideoFromYoutubeSemitagNamesDuplicatedError {
  name: String!
}

"""成功した場合"""
type RegisterVideoFromYoutubeSucceededPayload {
  video: Video!
}

"""タグのIDが重複している"""
type RegisterVideoFromYoutubeTagIdsDuplicatedError {
  tagId: String!
}

input RejectNicovideoRegistrationRequestInput {
  note: String!
  requestId: ID!
}

enum RejectNicovideoRegistrationRequestOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type RejectNicovideoRegistrationRequestOtherErrorsFallback {
  message: RejectNicovideoRegistrationRequestOtherErrorMessage!
}

"""リクエストが既に処理されている場合のエラー"""
type RejectNicovideoRegistrationRequestRequestAlreadyCheckedError {
  request: NicovideoRegistrationRequest!
}

union RejectNicovideoRegistrationRequestReturnUnion = MutationInvalidNicovideoRegistrationRequestIdError | MutationNicovideoRegistrationRequestNotFoundError | RejectNicovideoRegistrationRequestOtherErrorsFallback | RejectNicovideoRegistrationRequestRequestAlreadyCheckedError | RejectNicovideoRegistrationRequestSucceededPayload

type RejectNicovideoRegistrationRequestSucceededPayload {
  rejecting: NicovideoRegistrationRequestRejecting!
}

"""その他のエラー"""
type RejectSemitagOtherErrorsFallback {
  message: RejectSemitagOtherErrorsFallbackMessage!
}

enum RejectSemitagOtherErrorsFallbackMessage {
  INTERNAL_SERVER_ERROR
}

union RejectSemitagReturnUnion = MutationInvalidSemitagIdError | MutationInvalidTagIdError | MutationSemitagAlreadyCheckedError | MutationSemitagNotFoundError | MutationTagNotFoundError | RejectSemitagOtherErrorsFallback | RejectSemitagSucceededPayload

type RejectSemitagSucceededPayload {
  rejecting: SemitagRejecting!
}

enum RemoveTagFromVideoFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  INVALID_VIDEO_ID
  NO_TAGGING
  TAGGING_ALREADY_REMOVED
  TAG_NOT_FOUND

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_NOT_FOUND
}

type RemoveTagFromVideoFailedPayload {
  message: RemoveTagFromVideoFailedMessage!
}

input RemoveTagFromVideoInput {
  tagId: ID!
  videoId: ID!
}

union RemoveTagFromVideoPayload = RemoveTagFromVideoFailedPayload | RemoveTagFromVideoSucceededPayload

type RemoveTagFromVideoSucceededPayload {
  tag: Tag!
  video: Video!
}

enum RemoveVideoFromMylistFailedMessage {
  ALREADY_UNREGISTERED
  FORBIDDEN
  INVALID_MYLIST_ID
  INVALID_VIDEO_ID
  MYLIST_NOT_FOUND
  NOT_REGISTERED
  UNKNOWN
  VIDEO_NOT_FOUND
  WRONG_MYLIST_HOLDER
}

type RemoveVideoFromMylistFailedPayload {
  message: RemoveVideoFromMylistFailedMessage!
}

input RemoveVideoFromMylistInput {
  mylistId: ID!
  videoId: ID!
}

union RemoveVideoFromMylistPayload = RemoveVideoFromMylistFailedPayload | RemoveVideoFromMylistSucceededPayload

type RemoveVideoFromMylistSucceededPayload {
  mylist: Mylist!
  video: Video!
}

input RequestNicovideoRegistrationInput {
  semitaggings: [RequestNicovideoRegistrationInputSemitagging!]!
  sourceId: String!
  taggings: [RequestNicovideoRegistrationInputTagging!]!
  thumbnailUrl: String!
  title: String!
}

input RequestNicovideoRegistrationInputSemitagging {
  name: String!
  note: String
}

input RequestNicovideoRegistrationInputTagging {
  note: String
  tagId: ID!
}

enum RequestNicovideoRegistrationOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type RequestNicovideoRegistrationOtherErrorsFallback {
  message: RequestNicovideoRegistrationOtherErrorMessage!
}

union RequestNicovideoRegistrationReturnUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RequestNicovideoRegistrationOtherErrorsFallback | RequestNicovideoRegistrationSucceededPayload | RequestNicovideoRegistrationVideoAlreadyRegisteredError

type RequestNicovideoRegistrationSucceededPayload {
  request: NicovideoRegistrationRequest!
}

"""動画が既に登録されている場合のエラー"""
type RequestNicovideoRegistrationVideoAlreadyRegisteredError {
  source: NicovideoVideoSource!
}

"""その他のエラー"""
type ResolveSemitagOtherErrorsFallback {
  message: ResolveSemitagOtherErrorsFallbackMessage!
}

enum ResolveSemitagOtherErrorsFallbackMessage {
  INTERNAL_SERVER_ERROR
}

union ResolveSemitagReturnUnion = MutationInvalidSemitagIdError | MutationInvalidTagIdError | MutationSemitagAlreadyCheckedError | MutationSemitagNotFoundError | MutationTagNotFoundError | ResolveSemitagOtherErrorsFallback | ResolveSemitagSucceededPayload | ResolveSemitagVideoAlreadyTaggedPayload

type ResolveSemitagSucceededPayload {
  resolving: SemitagResolving!
}

"""すでに動画に同じタグ付けが行われている場合のエラー"""
type ResolveSemitagVideoAlreadyTaggedPayload {
  tagging: VideoTag!
}

input SearchTagInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchTagsPayload {
  items: [TagSearchItemByName!]!
}

input SearchVideoInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchVideosPayload {
  items: [VideoSearchItemByTitle!]!
}

type Semitag implements Node {
  check: SemitagChecking
  checked: Boolean!
  events(input: SemitagEventsInput!): SemitagEventConnection!
  id: ID!
  name: String!
  resolved: Boolean! @deprecated
  resolvedTag: Tag @deprecated
  suggestTags(limit: Int! = 3, skip: Int! = 0): SemitagSuggestTagsReturn!
  video: Video!
}

type SemitagAttachEvent implements Event & Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  semitag: Semitag!
  series: String!
  user: User!
}

union SemitagChecking = SemitagRejecting | SemitagResolving

type SemitagConnection {
  edges: [SemitagEdge!]!
  nodes: [Semitag!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SemitagEdge {
  cursor: String!
  node: Semitag!
}

interface SemitagEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
}

type SemitagEventConnection {
  nodes: [SemitagEvent!]!
}

input SemitagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type SemitagRejectEvent implements Event & Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  rejecting: SemitagRejecting!
  series: String!
  user: User!
}

type SemitagRejecting {
  note: String
  semitag: Semitag!
}

type SemitagResolveEvent implements Event & Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  resolving: SemitagResolving!
  series: String!
  user: User!
}

type SemitagResolving {
  note: String
  resolveTo: VideoTag!
  semitag: Semitag!
}

type SemitagSuggestTagsItem {
  canResolveTo: Boolean!
  name: TagName!
  tag: Tag!
}

type SemitagSuggestTagsReturn {
  items: [SemitagSuggestTagsItem!]!
}

enum SortOrder {
  ASC
  DESC
}

type Tag implements Node {
  """動画に対してタグを付けることができるか"""
  canTagTo(
    """動画のID"""
    videoId: ID!
  ): Boolean!
  children(after: String, before: String, first: Int, last: Int, orderBy: TagChildrenOrderBy! = {createdAt: DESC}): TagParentConnection!
  events(input: TagEventsInput!): TagEventsConnection!
  explicitParent: Tag
  id: ID!
  isCategoryTag: Boolean!
  meaningless: Boolean! @deprecated
  name: String!
  names(primary: Boolean): [TagName!]!
  parents(after: String, before: String, categoryTag: Boolean, first: Int, last: Int, orderBy: TagParentsOrderBy! = {createdAt: DESC}): TagParentConnection!
  serial: Int!
  taggedVideos(after: String, before: String, first: Int, last: Int, orderBy: TagTaggedVideosOrderBy! = {createdAt: DESC}): VideoTagConnection!
  type: TagType!
}

input TagChildrenOrderBy {
  createdAt: SortOrder
}

type TagConnection {
  nodes: [Tag!]!
}

interface TagEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  tag: Tag!
  user: User!
}

type TagEventsConnection {
  nodes: [TagEvent!]!
}

input TagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type TagName {
  events(input: TagNameEventsInput!): TagNameEventConnection!
  id: ID!
  name: String!
  primary: Boolean!
}

type TagNameCreateEvent implements Event & Node & TagNameEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

interface TagNameEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

type TagNameEventConnection {
  nodes: [TagNameEvent!]!
}

input TagNameEventsInput {
  limit: Int
  skip: Int! = 0
}

type TagNameSetPrimaryEvent implements Event & Node & TagNameEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

type TagNameUnsetPrimaryEvent implements Event & Node & TagNameEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

type TagParent {
  child: Tag!
  events(input: TagParentEventsInput!): TagParentEventConnection!
  explicit: Boolean!
  id: ID!
  parent: Tag!
}

type TagParentConnection {
  edges: [TagParentEdge!]!
  nodes: [TagParent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TagParentCreateEvent implements Event & Node & TagParentEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

type TagParentEdge {
  cursor: String!
  node: TagParent!
}

interface TagParentEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

type TagParentEventConnection {
  nodes: [TagParentEvent!]!
}

input TagParentEventsInput {
  limit: Int
  skip: Int! = 0
}

type TagParentSetPrimaryEvent implements Event & Node & TagParentEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

type TagParentUnsetPrimaryEvent implements Event & Node & TagParentEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

input TagParentsOrderBy {
  createdAt: SortOrder
}

"""Tagを追加した際に発生．（初回のみ）"""
type TagRegisterEvent implements Event & Node & TagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tag: Tag!
  user: User!
}

type TagSearchItemByName {
  name: TagName!
  tag: Tag!
}

input TagTaggedVideosOrderBy {
  createdAt: SortOrder
}

enum TagType {
  """キャラクター"""
  CHARACTER

  """動画の内容に依らない情報，分類など"""
  CLASS

  """作品名"""
  COPYRIGHT

  """合作などのイベント"""
  EVENT

  """曲"""
  MUSIC

  """特徴的なセリフなど"""
  PHRASE

  """シリーズ"""
  SERIES

  """動画そのものに対しての性質，作風など"""
  STYLE

  """2つ以上のタイプが算出された場合"""
  SUBTLE

  """戦法"""
  TACTICS

  """タイプを算出できなかった場合"""
  UNKNOWN
}

input UndoLikeVideoInput {
  videoId: ID!
}

type UndoLikeVideoNotLikedError {
  likes: Mylist!
  video: Video!
}

union UndoLikeVideoReturnUnion = MutationInvalidVideoIdError | MutationVideoNotFoundError | UndoLikeVideoNotLikedError | UndoLikeVideoSucceededPayload

type UndoLikeVideoSucceededPayload {
  registration: MylistRegistration!
}

type User implements Node {
  displayName: String!
  icon: String!
  id: ID!
  isAdministrator: Boolean!
  isEditor: Boolean!
  likes: Mylist
  mylist(id: ID!): Mylist
  mylists(after: String, before: String, first: Int, last: Int, orderBy: UserMylistsOrderBy! = {createdAt: DESC}, range: [MylistShareRange!]! = [PUBLIC]): MylistConnection!
  name: String!
  hasRole(role: UserRole!): Boolean
  nicovideoRegistrationRequests(after: String, before: String, first: Int, last: Int, orderBy: UserNicovideoRegistrationRequestsOrderBy! = {createdAt: DESC}): NicovideoRegistrationRequestConnection!
}

enum UserRole {
  ADMIN
  EDITOR
}

input UserMylistsOrderBy {
  createdAt: SortOrder
}

input UserNicovideoRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

union VerifyTemporaryUserReturnUnion = VerifyTemporaryUserSucceededPayload

type VerifyTemporaryUserSucceededPayload {
  id: ID!
}

type Video implements Node {
  events(input: VideoEventsInput!): VideoEventsConnection!
  hasTag(id: ID!): Boolean!
  id: ID!
  isLiked: Boolean!
  like: MylistRegistration
  nicovideoSources: [NicovideoVideoSource!]!
  registeredAt: DateTime!
  semitags(checked: Boolean): [Semitag!]!
  serial: Int!
  similarVideos(input: VideoSimilarVideosInput!): VideoSimilarVideosPayload!
  taggings(after: String, before: String, first: Int, last: Int, orderBy: VideoTaggingsOrderBy! = {createdAt: DESC}): VideoTagConnection!
  thumbnailUrl: String!
  thumbnails: [VideoThumbnail!]!
  title: String!
  titles: [VideoTitle!]!
  youtubeSources: [YoutubeVideoSource!]!
}

type VideoConnection {
  edges: [VideoEdge!]!
  nodes: [Video!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoEdge {
  cursor: String!
  node: Video!
}

interface VideoEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  video: Video!
}

type VideoEventsConnection {
  nodes: [VideoEvent!]!
}

input VideoEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

"""Videoを追加した際に発生．（初回のみ）"""
type VideoRegisterEvent implements Event & Node & VideoEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  video: Video!
}

type VideoSearchItemByTitle {
  title: VideoTitle!
  video: Video!
}

input VideoSimilarVideosInput {
  limit: Int! = 10
}

type VideoSimilarVideosPayload {
  items: [VideoSimilarity!]!
}

type VideoSimilarity {
  origin: Video!
  score: Float!
  to: Video!
}

interface VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type VideoTag {
  events(input: VideoTagEventsInput!): VideoTagEventsConnection!
  id: ID!
  tag: Tag!
  video: Video!
}

type VideoTagAttachEvent implements Event & Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

type VideoTagConnection {
  edges: [VideoTagEdge!]!
  nodes: [VideoTag!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoTagDetachEvent implements Event & Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

type VideoTagEdge {
  cursor: String!
  node: VideoTag!
}

interface VideoTagEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

type VideoTagEventsConnection {
  nodes: [VideoTagEvent!]!
}

input VideoTagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoTagReattachEvent implements Event & Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

input VideoTaggingsOrderBy {
  createdAt: SortOrder
}

type VideoThumbnail {
  events(input: VideoThumbnailEventsInput!): VideoThumbnailEventsConnection!
  id: ID!
  imageUrl: String!
  primary: Boolean!
  video: Video!
}

type VideoThumbnailCreateEvent implements Event & Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

interface VideoThumbnailEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoThumbnailEventsConnection {
  nodes: [VideoThumbnailEvent!]!
}

input VideoThumbnailEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoThumbnailSetPrimaryEvent implements Event & Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoThumbnailUnsetPrimaryEvent implements Event & Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoTitle {
  events(input: VideoTitleEventsInput!): VideoTitleEventsConnection!
  id: ID!
  primary: Boolean!
  title: String!
  video: Video!
}

type VideoTitleCreateEvent implements Event & Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

interface VideoTitleEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

type VideoTitleEventsConnection {
  nodes: [VideoTitleEvent!]!
}

input VideoTitleEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoTitleSetPrimaryEvent implements Event & Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

type VideoTitleUnsetPrimaryEvent implements Event & Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

type YoutubeOriginalSource {
  sourceId: String!
  thumbnailUrl: String!
}

type YoutubeVideoSource implements Node & VideoSource {
  embedUrl: String!
  events(after: String, before: String, first: Int, last: Int, orderBy: YoutubeVideoSourceEventsOrderBy!): YoutubeVideoSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type YoutubeVideoSourceCreateEvent implements Event & Node & YoutubeVideoSourceEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: YoutubeVideoSource!
  user: User!
}

interface YoutubeVideoSourceEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: YoutubeVideoSource!
  user: User!
}

type YoutubeVideoSourceEventConnection {
  edges: [YoutubeVideoSourceEventEdge!]!
  nodes: [YoutubeVideoSourceEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type YoutubeVideoSourceEventEdge {
  cursor: String!
  node: YoutubeVideoSourceEvent!
}

input YoutubeVideoSourceEventsOrderBy {
  createdAt: SortOrder
}